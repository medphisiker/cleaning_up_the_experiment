# Очистка эксперимента

Учёные провели ряд экспериментов, но из-за неисправности оборудования некоторые результаты оказались ошибочными. Ошибочные результаты представлены числом element. Ваша задача — удалить все вхождения числа element из массива, сохранив порядок остальных чисел.

## Формат входных данных
В первой строке задаётся число  N  — размер массива (количество элементов).
Во второй строке вводится массив из  N  чисел, разделённых пробелами.
В третьей строке задаётся число element, которое нужно удалить из массива.

## Формат выходных данных
На выходе программа должна вывести строку из элементов массива, из которого удалены все вхождения числа element. Оставшиеся числа должны быть записаны через пробел.

## Пример 1
Входные данные
```
7
1 2 -1 4 5 -1 6
-1
```
Выходные данные
```
1 2 4 5 6
```


## Реализации

### In-place фильтрация (функция `remove_in_place`)
- **Принцип работы**: 
Два указателя: 
1. Читающий указатель (read) — движется от начала к концу.
2. Пишущий указатель (write) — указывает, куда класть "хорошие" элементы.
Они движутся независимо:
* read всегда увеличивается на 1 на каждой итерации.
* write увеличивается только когда элемент не равен значению которое нужно удалить.

- Когда read и write совпадают — массив не изменяется.
- Когда read > write — между ними находятся удаляемые элементы.
- В конце обрезается "хвост" — всё, что после write_index.

Это классический, эффективный и элегантный подход к обработке массивов in-place.

- **Сложность**:
  - Временная: $O(n)$
  - Пространственная: $O(1)$
- **Особенности**: модифицирует исходный массив
- **Использование**: рекомендуется для больших массивов при ограничениях по памяти

### Фильтрация с созданием нового массива (функция `create_filtered_copy`)
- **Принцип работы**: создается новый массив, содержащий только элементы, не равные заданному значению
- **Сложность**:
  - Временная: $O(n)$
  - Пространственная: $O(n)$
- **Особенности**: возвращает новый массив, исходный массив не изменяется
- **Использование**: рекомендуется для небольших массивов или когда нужно сохранить исходные данные

В основном блоке программы используется реализация `remove_in_place` (in-place) как наиболее эффективная по памяти.

## Советы ментора

### 1. Выбор подхода
- **In-place (remove_in_place)**
  Используйте при работе с большими массивами и ограничениями по памяти. Учитывайте, что исходные данные будут изменены.
- **Создание нового массива (create_filtered_copy)**
  Предпочтителен когда нужно сохранить исходные данные. Подходит для небольших массивов.

### 2. Обработка пограничных случаев
Всегда проверяйте:
- Пустой массив на входе
- Отсутствие искомого элемента в массиве
- Все элементы массива равны искомому значению
- Очень большие массивы (стресс-тестирование)

### 3. Оптимизация производительности
- Для in-place операций используйте срезы вместо поэлементного удаления
- Избегайте лишних операций копирования данных
- Документируйте временную и пространственную сложность решения

### 4. Читаемость и сопровождение
- Используйте осмысленные имена переменных.
- Добавляйте docstrings с описанием параметров и возвращаемых значений
- Разделяйте сложные операции на логические блоки
- Комментируйте нетривиальные решения

### 5. Тестирование
Всегда пишите тесты, проверяющие:
- Корректность работы алгоритма
- Пограничные случаи
- Производительность на больших данных
- Сохранение порядка элементов

Пример теста:
```python
def test_remove_in_place():
    # Тест удаления всех элементов
    assert remove_in_place([1,1,1], 1) == []
    # Тест отсутствия элемента
    assert remove_in_place([1,2,3], 4) == [1,2,3]
    # Тест сохранения порядка
    assert remove_in_place([3,2,1], 2) == [3,1]
```
